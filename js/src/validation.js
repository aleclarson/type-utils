// Generated by CoffeeScript 1.10.0
(function() {
  var getTypeNames;

  getTypeNames = require("./helpers").getTypeNames;

  module.exports = function(TU) {
    var addValidatorType, validateType, validateTypes, validateWithArray, validateWithFunction, validatorTypeCache;
    validatorTypeCache = [];
    validateType = function(value, validator, keyPath) {
      var i, len, ref, type, validate;
      for (i = 0, len = validatorTypeCache.length; i < len; i++) {
        ref = validatorTypeCache[i], type = ref.type, validate = ref.validate;
        if (TU.isType(validator, type)) {
          return validate(value, validator, keyPath);
        }
      }
      if (global.failure == null) {
        global.failure = {
          key: keyPath,
          value: value,
          validator: validator
        };
      }
      throw TypeError("'validator' has an unexpected type.");
    };
    validateTypes = function(obj, validators, keyPath) {
      var key, validator, value;
      if (validators == null) {
        return;
      }
      TU.assertType(validators, Object, keyPath);
      for (key in validators) {
        validator = validators[key];
        value = obj[key];
        if (keyPath != null) {
          key = keyPath + "." + key;
        }
        if (TU.isType(validator, Object)) {
          if (value == null) {
            continue;
          }
          TU.assertKind(value, Object, key);
          validateTypes(value, validator, key);
        } else {
          validateType(value, validator, key);
        }
      }
    };
    addValidatorType = function(type, validate) {
      return validatorTypeCache.push({
        type: type,
        validate: validate
      });
    };
    validateWithFunction = function(value, validator, keyPath) {
      return validator(value, keyPath);
    };
    validateWithArray = function(value, types, keyPath) {
      var typeNames;
      if (types.length === 0) {
        return;
      }
      if (types.length === 1) {
        return TU.assertType(value, types[0], keyPath);
      }
      if (TU.isType(value, types)) {
        return;
      }
      if (global.failure == null) {
        global.failure = {
          key: keyPath,
          value: value,
          types: types
        };
      }
      keyPath = keyPath != null ? "'" + keyPath + "'" : "This property";
      typeNames = getTypeNames(types);
      throw TypeError(keyPath + " must be a " + typeNames);
    };
    addValidatorType(Function, validateWithFunction);
    addValidatorType(Array, validateWithArray);
    return {
      validateTypes: validateTypes,
      addValidatorType: addValidatorType
    };
  };

}).call(this);
